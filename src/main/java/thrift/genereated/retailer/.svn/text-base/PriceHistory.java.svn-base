/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package thrift.genereated.retailer;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.thrift.EncodingUtils;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;
import org.apache.thrift.scheme.TupleScheme;

public class PriceHistory implements org.apache.thrift.TBase<PriceHistory, PriceHistory._Fields>, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("PriceHistory");

  private static final org.apache.thrift.protocol.TField PRICE_TICKS_FIELD_DESC = new org.apache.thrift.protocol.TField("priceTicks", org.apache.thrift.protocol.TType.LIST, (short)1);
  private static final org.apache.thrift.protocol.TField CURR_PRICE_FIELD_DESC = new org.apache.thrift.protocol.TField("currPrice", org.apache.thrift.protocol.TType.DOUBLE, (short)2);
  private static final org.apache.thrift.protocol.TField MAX_PRICE_FIELD_DESC = new org.apache.thrift.protocol.TField("maxPrice", org.apache.thrift.protocol.TType.DOUBLE, (short)3);
  private static final org.apache.thrift.protocol.TField MIN_PRICE_FIELD_DESC = new org.apache.thrift.protocol.TField("minPrice", org.apache.thrift.protocol.TType.DOUBLE, (short)4);
  private static final org.apache.thrift.protocol.TField CURR_PRICE_FROM_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("currPriceFromTime", org.apache.thrift.protocol.TType.I64, (short)5);
  private static final org.apache.thrift.protocol.TField MIN_PRICE_FROM_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("minPriceFromTime", org.apache.thrift.protocol.TType.I64, (short)6);
  private static final org.apache.thrift.protocol.TField MIN_PRICE_TO_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("minPriceToTime", org.apache.thrift.protocol.TType.I64, (short)7);
  private static final org.apache.thrift.protocol.TField MAX_PRICE_FROM_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("maxPriceFromTime", org.apache.thrift.protocol.TType.I64, (short)8);
  private static final org.apache.thrift.protocol.TField MAX_PRICE_TO_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("maxPriceToTime", org.apache.thrift.protocol.TType.I64, (short)9);
  private static final org.apache.thrift.protocol.TField AVERAGE_PRICE_FIELD_DESC = new org.apache.thrift.protocol.TField("averagePrice", org.apache.thrift.protocol.TType.DOUBLE, (short)10);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new PriceHistoryStandardSchemeFactory());
    schemes.put(TupleScheme.class, new PriceHistoryTupleSchemeFactory());
  }

  public List<Tick> priceTicks; // required
  public double currPrice; // required
  public double maxPrice; // required
  public double minPrice; // required
  public long currPriceFromTime; // required
  public long minPriceFromTime; // required
  public long minPriceToTime; // required
  public long maxPriceFromTime; // required
  public long maxPriceToTime; // required
  public double averagePrice; // optional

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    PRICE_TICKS((short)1, "priceTicks"),
    CURR_PRICE((short)2, "currPrice"),
    MAX_PRICE((short)3, "maxPrice"),
    MIN_PRICE((short)4, "minPrice"),
    CURR_PRICE_FROM_TIME((short)5, "currPriceFromTime"),
    MIN_PRICE_FROM_TIME((short)6, "minPriceFromTime"),
    MIN_PRICE_TO_TIME((short)7, "minPriceToTime"),
    MAX_PRICE_FROM_TIME((short)8, "maxPriceFromTime"),
    MAX_PRICE_TO_TIME((short)9, "maxPriceToTime"),
    AVERAGE_PRICE((short)10, "averagePrice");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // PRICE_TICKS
          return PRICE_TICKS;
        case 2: // CURR_PRICE
          return CURR_PRICE;
        case 3: // MAX_PRICE
          return MAX_PRICE;
        case 4: // MIN_PRICE
          return MIN_PRICE;
        case 5: // CURR_PRICE_FROM_TIME
          return CURR_PRICE_FROM_TIME;
        case 6: // MIN_PRICE_FROM_TIME
          return MIN_PRICE_FROM_TIME;
        case 7: // MIN_PRICE_TO_TIME
          return MIN_PRICE_TO_TIME;
        case 8: // MAX_PRICE_FROM_TIME
          return MAX_PRICE_FROM_TIME;
        case 9: // MAX_PRICE_TO_TIME
          return MAX_PRICE_TO_TIME;
        case 10: // AVERAGE_PRICE
          return AVERAGE_PRICE;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __CURRPRICE_ISSET_ID = 0;
  private static final int __MAXPRICE_ISSET_ID = 1;
  private static final int __MINPRICE_ISSET_ID = 2;
  private static final int __CURRPRICEFROMTIME_ISSET_ID = 3;
  private static final int __MINPRICEFROMTIME_ISSET_ID = 4;
  private static final int __MINPRICETOTIME_ISSET_ID = 5;
  private static final int __MAXPRICEFROMTIME_ISSET_ID = 6;
  private static final int __MAXPRICETOTIME_ISSET_ID = 7;
  private static final int __AVERAGEPRICE_ISSET_ID = 8;
  private short __isset_bitfield = 0;
  private _Fields optionals[] = {_Fields.AVERAGE_PRICE};
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.PRICE_TICKS, new org.apache.thrift.meta_data.FieldMetaData("priceTicks", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, Tick.class))));
    tmpMap.put(_Fields.CURR_PRICE, new org.apache.thrift.meta_data.FieldMetaData("currPrice", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.DOUBLE)));
    tmpMap.put(_Fields.MAX_PRICE, new org.apache.thrift.meta_data.FieldMetaData("maxPrice", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.DOUBLE)));
    tmpMap.put(_Fields.MIN_PRICE, new org.apache.thrift.meta_data.FieldMetaData("minPrice", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.DOUBLE)));
    tmpMap.put(_Fields.CURR_PRICE_FROM_TIME, new org.apache.thrift.meta_data.FieldMetaData("currPriceFromTime", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MIN_PRICE_FROM_TIME, new org.apache.thrift.meta_data.FieldMetaData("minPriceFromTime", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MIN_PRICE_TO_TIME, new org.apache.thrift.meta_data.FieldMetaData("minPriceToTime", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MAX_PRICE_FROM_TIME, new org.apache.thrift.meta_data.FieldMetaData("maxPriceFromTime", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MAX_PRICE_TO_TIME, new org.apache.thrift.meta_data.FieldMetaData("maxPriceToTime", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.AVERAGE_PRICE, new org.apache.thrift.meta_data.FieldMetaData("averagePrice", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.DOUBLE)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(PriceHistory.class, metaDataMap);
  }

  public PriceHistory() {
  }

  public PriceHistory(
    List<Tick> priceTicks,
    double currPrice,
    double maxPrice,
    double minPrice,
    long currPriceFromTime,
    long minPriceFromTime,
    long minPriceToTime,
    long maxPriceFromTime,
    long maxPriceToTime)
  {
    this();
    this.priceTicks = priceTicks;
    this.currPrice = currPrice;
    setCurrPriceIsSet(true);
    this.maxPrice = maxPrice;
    setMaxPriceIsSet(true);
    this.minPrice = minPrice;
    setMinPriceIsSet(true);
    this.currPriceFromTime = currPriceFromTime;
    setCurrPriceFromTimeIsSet(true);
    this.minPriceFromTime = minPriceFromTime;
    setMinPriceFromTimeIsSet(true);
    this.minPriceToTime = minPriceToTime;
    setMinPriceToTimeIsSet(true);
    this.maxPriceFromTime = maxPriceFromTime;
    setMaxPriceFromTimeIsSet(true);
    this.maxPriceToTime = maxPriceToTime;
    setMaxPriceToTimeIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public PriceHistory(PriceHistory other) {
    __isset_bitfield = other.__isset_bitfield;
    if (other.isSetPriceTicks()) {
      List<Tick> __this__priceTicks = new ArrayList<Tick>();
      for (Tick other_element : other.priceTicks) {
        __this__priceTicks.add(new Tick(other_element));
      }
      this.priceTicks = __this__priceTicks;
    }
    this.currPrice = other.currPrice;
    this.maxPrice = other.maxPrice;
    this.minPrice = other.minPrice;
    this.currPriceFromTime = other.currPriceFromTime;
    this.minPriceFromTime = other.minPriceFromTime;
    this.minPriceToTime = other.minPriceToTime;
    this.maxPriceFromTime = other.maxPriceFromTime;
    this.maxPriceToTime = other.maxPriceToTime;
    this.averagePrice = other.averagePrice;
  }

  public PriceHistory deepCopy() {
    return new PriceHistory(this);
  }

  @Override
  public void clear() {
    this.priceTicks = null;
    setCurrPriceIsSet(false);
    this.currPrice = 0.0;
    setMaxPriceIsSet(false);
    this.maxPrice = 0.0;
    setMinPriceIsSet(false);
    this.minPrice = 0.0;
    setCurrPriceFromTimeIsSet(false);
    this.currPriceFromTime = 0;
    setMinPriceFromTimeIsSet(false);
    this.minPriceFromTime = 0;
    setMinPriceToTimeIsSet(false);
    this.minPriceToTime = 0;
    setMaxPriceFromTimeIsSet(false);
    this.maxPriceFromTime = 0;
    setMaxPriceToTimeIsSet(false);
    this.maxPriceToTime = 0;
    setAveragePriceIsSet(false);
    this.averagePrice = 0.0;
  }

  public int getPriceTicksSize() {
    return (this.priceTicks == null) ? 0 : this.priceTicks.size();
  }

  public java.util.Iterator<Tick> getPriceTicksIterator() {
    return (this.priceTicks == null) ? null : this.priceTicks.iterator();
  }

  public void addToPriceTicks(Tick elem) {
    if (this.priceTicks == null) {
      this.priceTicks = new ArrayList<Tick>();
    }
    this.priceTicks.add(elem);
  }

  public List<Tick> getPriceTicks() {
    return this.priceTicks;
  }

  public PriceHistory setPriceTicks(List<Tick> priceTicks) {
    this.priceTicks = priceTicks;
    return this;
  }

  public void unsetPriceTicks() {
    this.priceTicks = null;
  }

  /** Returns true if field priceTicks is set (has been assigned a value) and false otherwise */
  public boolean isSetPriceTicks() {
    return this.priceTicks != null;
  }

  public void setPriceTicksIsSet(boolean value) {
    if (!value) {
      this.priceTicks = null;
    }
  }

  public double getCurrPrice() {
    return this.currPrice;
  }

  public PriceHistory setCurrPrice(double currPrice) {
    this.currPrice = currPrice;
    setCurrPriceIsSet(true);
    return this;
  }

  public void unsetCurrPrice() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CURRPRICE_ISSET_ID);
  }

  /** Returns true if field currPrice is set (has been assigned a value) and false otherwise */
  public boolean isSetCurrPrice() {
    return EncodingUtils.testBit(__isset_bitfield, __CURRPRICE_ISSET_ID);
  }

  public void setCurrPriceIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CURRPRICE_ISSET_ID, value);
  }

  public double getMaxPrice() {
    return this.maxPrice;
  }

  public PriceHistory setMaxPrice(double maxPrice) {
    this.maxPrice = maxPrice;
    setMaxPriceIsSet(true);
    return this;
  }

  public void unsetMaxPrice() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXPRICE_ISSET_ID);
  }

  /** Returns true if field maxPrice is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxPrice() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXPRICE_ISSET_ID);
  }

  public void setMaxPriceIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXPRICE_ISSET_ID, value);
  }

  public double getMinPrice() {
    return this.minPrice;
  }

  public PriceHistory setMinPrice(double minPrice) {
    this.minPrice = minPrice;
    setMinPriceIsSet(true);
    return this;
  }

  public void unsetMinPrice() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MINPRICE_ISSET_ID);
  }

  /** Returns true if field minPrice is set (has been assigned a value) and false otherwise */
  public boolean isSetMinPrice() {
    return EncodingUtils.testBit(__isset_bitfield, __MINPRICE_ISSET_ID);
  }

  public void setMinPriceIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MINPRICE_ISSET_ID, value);
  }

  public long getCurrPriceFromTime() {
    return this.currPriceFromTime;
  }

  public PriceHistory setCurrPriceFromTime(long currPriceFromTime) {
    this.currPriceFromTime = currPriceFromTime;
    setCurrPriceFromTimeIsSet(true);
    return this;
  }

  public void unsetCurrPriceFromTime() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CURRPRICEFROMTIME_ISSET_ID);
  }

  /** Returns true if field currPriceFromTime is set (has been assigned a value) and false otherwise */
  public boolean isSetCurrPriceFromTime() {
    return EncodingUtils.testBit(__isset_bitfield, __CURRPRICEFROMTIME_ISSET_ID);
  }

  public void setCurrPriceFromTimeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CURRPRICEFROMTIME_ISSET_ID, value);
  }

  public long getMinPriceFromTime() {
    return this.minPriceFromTime;
  }

  public PriceHistory setMinPriceFromTime(long minPriceFromTime) {
    this.minPriceFromTime = minPriceFromTime;
    setMinPriceFromTimeIsSet(true);
    return this;
  }

  public void unsetMinPriceFromTime() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MINPRICEFROMTIME_ISSET_ID);
  }

  /** Returns true if field minPriceFromTime is set (has been assigned a value) and false otherwise */
  public boolean isSetMinPriceFromTime() {
    return EncodingUtils.testBit(__isset_bitfield, __MINPRICEFROMTIME_ISSET_ID);
  }

  public void setMinPriceFromTimeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MINPRICEFROMTIME_ISSET_ID, value);
  }

  public long getMinPriceToTime() {
    return this.minPriceToTime;
  }

  public PriceHistory setMinPriceToTime(long minPriceToTime) {
    this.minPriceToTime = minPriceToTime;
    setMinPriceToTimeIsSet(true);
    return this;
  }

  public void unsetMinPriceToTime() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MINPRICETOTIME_ISSET_ID);
  }

  /** Returns true if field minPriceToTime is set (has been assigned a value) and false otherwise */
  public boolean isSetMinPriceToTime() {
    return EncodingUtils.testBit(__isset_bitfield, __MINPRICETOTIME_ISSET_ID);
  }

  public void setMinPriceToTimeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MINPRICETOTIME_ISSET_ID, value);
  }

  public long getMaxPriceFromTime() {
    return this.maxPriceFromTime;
  }

  public PriceHistory setMaxPriceFromTime(long maxPriceFromTime) {
    this.maxPriceFromTime = maxPriceFromTime;
    setMaxPriceFromTimeIsSet(true);
    return this;
  }

  public void unsetMaxPriceFromTime() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXPRICEFROMTIME_ISSET_ID);
  }

  /** Returns true if field maxPriceFromTime is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxPriceFromTime() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXPRICEFROMTIME_ISSET_ID);
  }

  public void setMaxPriceFromTimeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXPRICEFROMTIME_ISSET_ID, value);
  }

  public long getMaxPriceToTime() {
    return this.maxPriceToTime;
  }

  public PriceHistory setMaxPriceToTime(long maxPriceToTime) {
    this.maxPriceToTime = maxPriceToTime;
    setMaxPriceToTimeIsSet(true);
    return this;
  }

  public void unsetMaxPriceToTime() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXPRICETOTIME_ISSET_ID);
  }

  /** Returns true if field maxPriceToTime is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxPriceToTime() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXPRICETOTIME_ISSET_ID);
  }

  public void setMaxPriceToTimeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXPRICETOTIME_ISSET_ID, value);
  }

  public double getAveragePrice() {
    return this.averagePrice;
  }

  public PriceHistory setAveragePrice(double averagePrice) {
    this.averagePrice = averagePrice;
    setAveragePriceIsSet(true);
    return this;
  }

  public void unsetAveragePrice() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __AVERAGEPRICE_ISSET_ID);
  }

  /** Returns true if field averagePrice is set (has been assigned a value) and false otherwise */
  public boolean isSetAveragePrice() {
    return EncodingUtils.testBit(__isset_bitfield, __AVERAGEPRICE_ISSET_ID);
  }

  public void setAveragePriceIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __AVERAGEPRICE_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case PRICE_TICKS:
      if (value == null) {
        unsetPriceTicks();
      } else {
        setPriceTicks((List<Tick>)value);
      }
      break;

    case CURR_PRICE:
      if (value == null) {
        unsetCurrPrice();
      } else {
        setCurrPrice((Double)value);
      }
      break;

    case MAX_PRICE:
      if (value == null) {
        unsetMaxPrice();
      } else {
        setMaxPrice((Double)value);
      }
      break;

    case MIN_PRICE:
      if (value == null) {
        unsetMinPrice();
      } else {
        setMinPrice((Double)value);
      }
      break;

    case CURR_PRICE_FROM_TIME:
      if (value == null) {
        unsetCurrPriceFromTime();
      } else {
        setCurrPriceFromTime((Long)value);
      }
      break;

    case MIN_PRICE_FROM_TIME:
      if (value == null) {
        unsetMinPriceFromTime();
      } else {
        setMinPriceFromTime((Long)value);
      }
      break;

    case MIN_PRICE_TO_TIME:
      if (value == null) {
        unsetMinPriceToTime();
      } else {
        setMinPriceToTime((Long)value);
      }
      break;

    case MAX_PRICE_FROM_TIME:
      if (value == null) {
        unsetMaxPriceFromTime();
      } else {
        setMaxPriceFromTime((Long)value);
      }
      break;

    case MAX_PRICE_TO_TIME:
      if (value == null) {
        unsetMaxPriceToTime();
      } else {
        setMaxPriceToTime((Long)value);
      }
      break;

    case AVERAGE_PRICE:
      if (value == null) {
        unsetAveragePrice();
      } else {
        setAveragePrice((Double)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case PRICE_TICKS:
      return getPriceTicks();

    case CURR_PRICE:
      return Double.valueOf(getCurrPrice());

    case MAX_PRICE:
      return Double.valueOf(getMaxPrice());

    case MIN_PRICE:
      return Double.valueOf(getMinPrice());

    case CURR_PRICE_FROM_TIME:
      return Long.valueOf(getCurrPriceFromTime());

    case MIN_PRICE_FROM_TIME:
      return Long.valueOf(getMinPriceFromTime());

    case MIN_PRICE_TO_TIME:
      return Long.valueOf(getMinPriceToTime());

    case MAX_PRICE_FROM_TIME:
      return Long.valueOf(getMaxPriceFromTime());

    case MAX_PRICE_TO_TIME:
      return Long.valueOf(getMaxPriceToTime());

    case AVERAGE_PRICE:
      return Double.valueOf(getAveragePrice());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case PRICE_TICKS:
      return isSetPriceTicks();
    case CURR_PRICE:
      return isSetCurrPrice();
    case MAX_PRICE:
      return isSetMaxPrice();
    case MIN_PRICE:
      return isSetMinPrice();
    case CURR_PRICE_FROM_TIME:
      return isSetCurrPriceFromTime();
    case MIN_PRICE_FROM_TIME:
      return isSetMinPriceFromTime();
    case MIN_PRICE_TO_TIME:
      return isSetMinPriceToTime();
    case MAX_PRICE_FROM_TIME:
      return isSetMaxPriceFromTime();
    case MAX_PRICE_TO_TIME:
      return isSetMaxPriceToTime();
    case AVERAGE_PRICE:
      return isSetAveragePrice();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof PriceHistory)
      return this.equals((PriceHistory)that);
    return false;
  }

  public boolean equals(PriceHistory that) {
    if (that == null)
      return false;

    boolean this_present_priceTicks = true && this.isSetPriceTicks();
    boolean that_present_priceTicks = true && that.isSetPriceTicks();
    if (this_present_priceTicks || that_present_priceTicks) {
      if (!(this_present_priceTicks && that_present_priceTicks))
        return false;
      if (!this.priceTicks.equals(that.priceTicks))
        return false;
    }

    boolean this_present_currPrice = true;
    boolean that_present_currPrice = true;
    if (this_present_currPrice || that_present_currPrice) {
      if (!(this_present_currPrice && that_present_currPrice))
        return false;
      if (this.currPrice != that.currPrice)
        return false;
    }

    boolean this_present_maxPrice = true;
    boolean that_present_maxPrice = true;
    if (this_present_maxPrice || that_present_maxPrice) {
      if (!(this_present_maxPrice && that_present_maxPrice))
        return false;
      if (this.maxPrice != that.maxPrice)
        return false;
    }

    boolean this_present_minPrice = true;
    boolean that_present_minPrice = true;
    if (this_present_minPrice || that_present_minPrice) {
      if (!(this_present_minPrice && that_present_minPrice))
        return false;
      if (this.minPrice != that.minPrice)
        return false;
    }

    boolean this_present_currPriceFromTime = true;
    boolean that_present_currPriceFromTime = true;
    if (this_present_currPriceFromTime || that_present_currPriceFromTime) {
      if (!(this_present_currPriceFromTime && that_present_currPriceFromTime))
        return false;
      if (this.currPriceFromTime != that.currPriceFromTime)
        return false;
    }

    boolean this_present_minPriceFromTime = true;
    boolean that_present_minPriceFromTime = true;
    if (this_present_minPriceFromTime || that_present_minPriceFromTime) {
      if (!(this_present_minPriceFromTime && that_present_minPriceFromTime))
        return false;
      if (this.minPriceFromTime != that.minPriceFromTime)
        return false;
    }

    boolean this_present_minPriceToTime = true;
    boolean that_present_minPriceToTime = true;
    if (this_present_minPriceToTime || that_present_minPriceToTime) {
      if (!(this_present_minPriceToTime && that_present_minPriceToTime))
        return false;
      if (this.minPriceToTime != that.minPriceToTime)
        return false;
    }

    boolean this_present_maxPriceFromTime = true;
    boolean that_present_maxPriceFromTime = true;
    if (this_present_maxPriceFromTime || that_present_maxPriceFromTime) {
      if (!(this_present_maxPriceFromTime && that_present_maxPriceFromTime))
        return false;
      if (this.maxPriceFromTime != that.maxPriceFromTime)
        return false;
    }

    boolean this_present_maxPriceToTime = true;
    boolean that_present_maxPriceToTime = true;
    if (this_present_maxPriceToTime || that_present_maxPriceToTime) {
      if (!(this_present_maxPriceToTime && that_present_maxPriceToTime))
        return false;
      if (this.maxPriceToTime != that.maxPriceToTime)
        return false;
    }

    boolean this_present_averagePrice = true && this.isSetAveragePrice();
    boolean that_present_averagePrice = true && that.isSetAveragePrice();
    if (this_present_averagePrice || that_present_averagePrice) {
      if (!(this_present_averagePrice && that_present_averagePrice))
        return false;
      if (this.averagePrice != that.averagePrice)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  public int compareTo(PriceHistory other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    PriceHistory typedOther = (PriceHistory)other;

    lastComparison = Boolean.valueOf(isSetPriceTicks()).compareTo(typedOther.isSetPriceTicks());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPriceTicks()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.priceTicks, typedOther.priceTicks);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCurrPrice()).compareTo(typedOther.isSetCurrPrice());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCurrPrice()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.currPrice, typedOther.currPrice);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxPrice()).compareTo(typedOther.isSetMaxPrice());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxPrice()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxPrice, typedOther.maxPrice);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMinPrice()).compareTo(typedOther.isSetMinPrice());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMinPrice()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.minPrice, typedOther.minPrice);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCurrPriceFromTime()).compareTo(typedOther.isSetCurrPriceFromTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCurrPriceFromTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.currPriceFromTime, typedOther.currPriceFromTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMinPriceFromTime()).compareTo(typedOther.isSetMinPriceFromTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMinPriceFromTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.minPriceFromTime, typedOther.minPriceFromTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMinPriceToTime()).compareTo(typedOther.isSetMinPriceToTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMinPriceToTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.minPriceToTime, typedOther.minPriceToTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxPriceFromTime()).compareTo(typedOther.isSetMaxPriceFromTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxPriceFromTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxPriceFromTime, typedOther.maxPriceFromTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxPriceToTime()).compareTo(typedOther.isSetMaxPriceToTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxPriceToTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxPriceToTime, typedOther.maxPriceToTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAveragePrice()).compareTo(typedOther.isSetAveragePrice());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAveragePrice()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.averagePrice, typedOther.averagePrice);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("PriceHistory(");
    boolean first = true;

    sb.append("priceTicks:");
    if (this.priceTicks == null) {
      sb.append("null");
    } else {
      sb.append(this.priceTicks);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("currPrice:");
    sb.append(this.currPrice);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxPrice:");
    sb.append(this.maxPrice);
    first = false;
    if (!first) sb.append(", ");
    sb.append("minPrice:");
    sb.append(this.minPrice);
    first = false;
    if (!first) sb.append(", ");
    sb.append("currPriceFromTime:");
    sb.append(this.currPriceFromTime);
    first = false;
    if (!first) sb.append(", ");
    sb.append("minPriceFromTime:");
    sb.append(this.minPriceFromTime);
    first = false;
    if (!first) sb.append(", ");
    sb.append("minPriceToTime:");
    sb.append(this.minPriceToTime);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxPriceFromTime:");
    sb.append(this.maxPriceFromTime);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxPriceToTime:");
    sb.append(this.maxPriceToTime);
    first = false;
    if (isSetAveragePrice()) {
      if (!first) sb.append(", ");
      sb.append("averagePrice:");
      sb.append(this.averagePrice);
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    if (priceTicks == null) {
      throw new org.apache.thrift.protocol.TProtocolException("Required field 'priceTicks' was not present! Struct: " + toString());
    }
    // alas, we cannot check 'currPrice' because it's a primitive and you chose the non-beans generator.
    // alas, we cannot check 'maxPrice' because it's a primitive and you chose the non-beans generator.
    // alas, we cannot check 'minPrice' because it's a primitive and you chose the non-beans generator.
    // alas, we cannot check 'currPriceFromTime' because it's a primitive and you chose the non-beans generator.
    // alas, we cannot check 'minPriceFromTime' because it's a primitive and you chose the non-beans generator.
    // alas, we cannot check 'minPriceToTime' because it's a primitive and you chose the non-beans generator.
    // alas, we cannot check 'maxPriceFromTime' because it's a primitive and you chose the non-beans generator.
    // alas, we cannot check 'maxPriceToTime' because it's a primitive and you chose the non-beans generator.
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class PriceHistoryStandardSchemeFactory implements SchemeFactory {
    public PriceHistoryStandardScheme getScheme() {
      return new PriceHistoryStandardScheme();
    }
  }

  private static class PriceHistoryStandardScheme extends StandardScheme<PriceHistory> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, PriceHistory struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // PRICE_TICKS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list16 = iprot.readListBegin();
                struct.priceTicks = new ArrayList<Tick>(_list16.size);
                for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                {
                  Tick _elem18; // required
                  _elem18 = new Tick();
                  _elem18.read(iprot);
                  struct.priceTicks.add(_elem18);
                }
                iprot.readListEnd();
              }
              struct.setPriceTicksIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // CURR_PRICE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.currPrice = iprot.readDouble();
              struct.setCurrPriceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // MAX_PRICE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.maxPrice = iprot.readDouble();
              struct.setMaxPriceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // MIN_PRICE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.minPrice = iprot.readDouble();
              struct.setMinPriceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // CURR_PRICE_FROM_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.currPriceFromTime = iprot.readI64();
              struct.setCurrPriceFromTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // MIN_PRICE_FROM_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.minPriceFromTime = iprot.readI64();
              struct.setMinPriceFromTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // MIN_PRICE_TO_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.minPriceToTime = iprot.readI64();
              struct.setMinPriceToTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // MAX_PRICE_FROM_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.maxPriceFromTime = iprot.readI64();
              struct.setMaxPriceFromTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // MAX_PRICE_TO_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.maxPriceToTime = iprot.readI64();
              struct.setMaxPriceToTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // AVERAGE_PRICE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.averagePrice = iprot.readDouble();
              struct.setAveragePriceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      if (!struct.isSetCurrPrice()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'currPrice' was not found in serialized data! Struct: " + toString());
      }
      if (!struct.isSetMaxPrice()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'maxPrice' was not found in serialized data! Struct: " + toString());
      }
      if (!struct.isSetMinPrice()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'minPrice' was not found in serialized data! Struct: " + toString());
      }
      if (!struct.isSetCurrPriceFromTime()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'currPriceFromTime' was not found in serialized data! Struct: " + toString());
      }
      if (!struct.isSetMinPriceFromTime()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'minPriceFromTime' was not found in serialized data! Struct: " + toString());
      }
      if (!struct.isSetMinPriceToTime()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'minPriceToTime' was not found in serialized data! Struct: " + toString());
      }
      if (!struct.isSetMaxPriceFromTime()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'maxPriceFromTime' was not found in serialized data! Struct: " + toString());
      }
      if (!struct.isSetMaxPriceToTime()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'maxPriceToTime' was not found in serialized data! Struct: " + toString());
      }
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, PriceHistory struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (struct.priceTicks != null) {
        oprot.writeFieldBegin(PRICE_TICKS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, struct.priceTicks.size()));
          for (Tick _iter19 : struct.priceTicks)
          {
            _iter19.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CURR_PRICE_FIELD_DESC);
      oprot.writeDouble(struct.currPrice);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_PRICE_FIELD_DESC);
      oprot.writeDouble(struct.maxPrice);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MIN_PRICE_FIELD_DESC);
      oprot.writeDouble(struct.minPrice);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CURR_PRICE_FROM_TIME_FIELD_DESC);
      oprot.writeI64(struct.currPriceFromTime);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MIN_PRICE_FROM_TIME_FIELD_DESC);
      oprot.writeI64(struct.minPriceFromTime);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MIN_PRICE_TO_TIME_FIELD_DESC);
      oprot.writeI64(struct.minPriceToTime);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_PRICE_FROM_TIME_FIELD_DESC);
      oprot.writeI64(struct.maxPriceFromTime);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_PRICE_TO_TIME_FIELD_DESC);
      oprot.writeI64(struct.maxPriceToTime);
      oprot.writeFieldEnd();
      if (struct.isSetAveragePrice()) {
        oprot.writeFieldBegin(AVERAGE_PRICE_FIELD_DESC);
        oprot.writeDouble(struct.averagePrice);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class PriceHistoryTupleSchemeFactory implements SchemeFactory {
    public PriceHistoryTupleScheme getScheme() {
      return new PriceHistoryTupleScheme();
    }
  }

  private static class PriceHistoryTupleScheme extends TupleScheme<PriceHistory> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, PriceHistory struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      {
        oprot.writeI32(struct.priceTicks.size());
        for (Tick _iter20 : struct.priceTicks)
        {
          _iter20.write(oprot);
        }
      }
      oprot.writeDouble(struct.currPrice);
      oprot.writeDouble(struct.maxPrice);
      oprot.writeDouble(struct.minPrice);
      oprot.writeI64(struct.currPriceFromTime);
      oprot.writeI64(struct.minPriceFromTime);
      oprot.writeI64(struct.minPriceToTime);
      oprot.writeI64(struct.maxPriceFromTime);
      oprot.writeI64(struct.maxPriceToTime);
      BitSet optionals = new BitSet();
      if (struct.isSetAveragePrice()) {
        optionals.set(0);
      }
      oprot.writeBitSet(optionals, 1);
      if (struct.isSetAveragePrice()) {
        oprot.writeDouble(struct.averagePrice);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, PriceHistory struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      {
        org.apache.thrift.protocol.TList _list21 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, iprot.readI32());
        struct.priceTicks = new ArrayList<Tick>(_list21.size);
        for (int _i22 = 0; _i22 < _list21.size; ++_i22)
        {
          Tick _elem23; // required
          _elem23 = new Tick();
          _elem23.read(iprot);
          struct.priceTicks.add(_elem23);
        }
      }
      struct.setPriceTicksIsSet(true);
      struct.currPrice = iprot.readDouble();
      struct.setCurrPriceIsSet(true);
      struct.maxPrice = iprot.readDouble();
      struct.setMaxPriceIsSet(true);
      struct.minPrice = iprot.readDouble();
      struct.setMinPriceIsSet(true);
      struct.currPriceFromTime = iprot.readI64();
      struct.setCurrPriceFromTimeIsSet(true);
      struct.minPriceFromTime = iprot.readI64();
      struct.setMinPriceFromTimeIsSet(true);
      struct.minPriceToTime = iprot.readI64();
      struct.setMinPriceToTimeIsSet(true);
      struct.maxPriceFromTime = iprot.readI64();
      struct.setMaxPriceFromTimeIsSet(true);
      struct.maxPriceToTime = iprot.readI64();
      struct.setMaxPriceToTimeIsSet(true);
      BitSet incoming = iprot.readBitSet(1);
      if (incoming.get(0)) {
        struct.averagePrice = iprot.readDouble();
        struct.setAveragePriceIsSet(true);
      }
    }
  }

}

